.import 'Data/palette.gvasm' {Palette}
.import 'Data/spritemap.gvasm' {SpriteMap}
.import 'Data/tilemap.gvasm' {BackgroundTiles}
.import 'Data/Maps/spawnpoint.gvasm' {Map, Collision, Metadata}


// Header
    .arm
	.def ramarea = 0x02000000
	.def BallX = ramarea+32
	.def BallY = ramarea+33
	.def BallVX = ramarea+34
	.def BallVY = ramarea+35
	.def BallR =4

	//.org  0x08000000     // GBA ROM Address starts at 0x08000000       

	b	ProgramStart	//000h    4     ROM Entry Point  (32bit ARM branch opcode, eg. "B rom_start") 


.include 'Data/palette.gvasm'
.include 'Data/spritemap.gvasm'
.include 'Data/tilemap.gvasm'
.include 'Data/Maps/spawnpoint.gvasm'

.align 4 
// Program Start
ProgramStart:
    mov sp,#0x03000000 //initializing the stack pointer
	mov r4,#0x04000000 //this is the display control address
	mov r2,#0x1100 
    str r2,[r4]
    ldr r4,=0x04000008
    mov r2,#0x084
    str r2,[r4]




    

    ldr r2, =Palette
    // adr r2, Palette
    ldr r1, =0x05000200
    mov r3, #512
    mov r4, #2
    bl LoadTo 
    mov r1, #0x05000000
    bl LoadTo

    ldr r2, =SpriteMap
    ldr r1, =0x06010000
    mov r3, #32768
    mov r4, #2
    bl LoadTo
    
    ldr r2, =BackgroundTiles
    ldr r1, =0x06004000
    mov r3, #32768
    mov r4, #2
    bl LoadTo

    ldr r2, =Map
    mov r1, #0x06000000
    mov r3, #2048
    mov r4, #2
    bl LoadTo

    mov r1, #0x2000
    mov r2, #0x4000
    mov r3, #0x0
    mov r9, #64
    mov r10, #64

    add r0, r1, r9
    mov r11,#0x07000000
    strh r0, [r11]
    add r0, r2, r10
    ldr r11,=0x07000002
    strh r0, [r11]
    ldr r11,=0x07000004
    strh r3, [r11]
    mov r6, #0
InfLoop:
    //Wait for V-Blank
    ldr r0, =0x4000006
    ldrh r0, [r0]
    cmp r0, #161
    bne InfLoop

    // Count frames
    add r6, r6, #1
    cmp r6, #10 // Only proceed on every 10th frame
    blt InfLoop
    mov r6, #0

    ldr r0, =0x4000130
    ldrh r0, [r0]

    mov r1, #0x80 //bit mask for down input
    tst r0, r1
    beq MoveDown
    mov r1, #0x40 //bit mask for Up input
    tst r0, r1
    beq MoveUp
    mov r1, #0x20 //bit mask for Left input
    tst r0, r1
    beq MoveLeft
    mov r1, #0x10 //bit mask for Right input
    tst r0, r1
    beq MoveRight
     b InfLoop
    
    MoveDown:
        
    
        mov r1, #144
        cmp r9,r1
        addlt r9, r9, #1

        mov r2, #15
        and r2, r9, r2
        cmp r2, #0
        bne SkipCollisionCheckMD
            //at a boundary so we must check the Collision
            //tiley will be r1, tilex will be r2
            asr r1, r9, #4
            add r1, r1, #1
            asr r2, r10, #4
            mov r5, #16
            mul r3, r1, r5
            add r3, r3, r2
            ldr r0, =Collision
            ldrb r0, [r0, r3]
            cmp r0, #0x1
            subeq r9, r9, #1        

        SkipCollisionCheckMD:
        mov r1, #0x2000
        add r0, r1, r9
        mov r2,#0x07000000
        strh r0, [r2]

        mov r3, #0
        ldr r2,=0x07000004
        strh r3, [r2]
        b InfLoop

    MoveUp:
        mov r1, #0
        cmp r9,r1
        subgt r9, r9, #1
        
        mov r2, #15
        and r2, r9, r2
        cmp r2, #0
        bne SkipCollisionCheckMU
            //at a boundary so we must check the Collision
            //tiley will be r1, tilex will be r2
            asr r1, r9, #4
            sub r1, r1, #1
            asr r2, r10, #4
            mov r5, #16
            mul r3, r1, r5
            add r3, r3, r2
            ldr r0, =Collision
            ldrb r0, [r0, r3]
            cmp r0, #0x1
            addeq r9, r9, #1        

        SkipCollisionCheckMU:
        mov r1, #0x2000
        add r0, r1, r9
        mov r2,#0x07000000
        strh r0, [r2]
        mov r3, #12
        ldr r2,=0x07000004
        strh r3, [r2]
        b InfLoop
    
    MoveLeft:
        mov r1, #0
        cmp r10,r1
        subgt r10, r10, #1
        
        mov r2, #15
        and r2, r10, r2
        cmp r2, #0
        bne SkipCollisionCheckML
            //at a boundary so we must check the Collision
            //tiley will be r1, tilex will be r2
            asr r1, r9, #4
            asr r2, r10, #4
            sub r2, r2, #1
            mov r5, #16
            mul r3, r1, r5
            add r3, r3, r2
            ldr r0, =Collision
            ldrb r0, [r0, r3]
            cmp r0, #0x1
            addeq r10, r10, #1        

        SkipCollisionCheckML:
        mov r1, #0x4000
        add r0, r1, r10
        ldr r2,=0x07000002
        strh r0, [r2]

        mov r3, #4
        ldr r2,=0x07000004
        strh r3, [r2]
        b InfLoop

    MoveRight:
        mov r1, #224
        cmp r10,r1
        addlt r10, r10, #1
        
        mov r2, #15
        and r2, r10, r2
        cmp r2, #0
        bne SkipCollisionCheckMR
            //at a boundary so we must check the Collision
            //tiley will be r1, tilex will be r2
            asr r1, r9, #4
            asr r2, r10, #4
            add r2, r2, #1
            mov r5, #16
            mul r3, r1, r5
            add r3, r3, r2
            ldr r0, =Collision
            ldrb r0, [r0, r3]
            cmp r0, #0x1
            subeq r10, r10, #1        

        SkipCollisionCheckMR:

        mov r1, #0x4000
        add r0, r1, r10
        ldr r2,=0x07000002
        strh r0, [r2]

        mov r3, #8
        ldr r2,=0x07000004
        strh r3, [r2]
        b InfLoop

LoadTo:
    //Expects 3 inputs destinationAddress, srcAddress, Length, Step//
    stmfd sp!,{r0-r6, lr}
    mov r5, #0
DoLoop:
        cmp r3,r5
        ble ExitLoop
        ldr r6, [r2,r5]
        strh r6, [r1,r5]
        add r5, r5, r4
        b DoLoop
ExitLoop:
    ldmfd sp!,{r0-r6, lr}
    bx lr


.pool